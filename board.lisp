;;;; Puyopuyo game states representation

;;; Model

;; puyo: single color blob
;; puyos: up to 2D array of puyo; (0 0) bottom left, (rows columns)
;; puyopuyo: puyo blob, simple : the puyo array could be one generated by the game

(defparameter *colors* '(red blue purple yellow green trash))

(defclass puyo ()
  ((color :accessor color :initarg :color)))

(defclass puyopuyo ()
  ((puyos :accessor puyos :initarg :puyos)
   (simple :accessor simple)))

;; state
;; puyos : 2D array of puyos or nil if empty; (0 0) bottom left, (rows columns)
;; next : a puyopuyo blob to be dropped next
;; resolved : are there outstanding combinations on the board?

(defclass state ()
  ((puyos :accessor puyos :initarg :puyos)
   (next-puyopuyo :accessor next)
   (resolved :accessor res :initform t)))

(defclass board ()
  ((width :accessor w :initform 6
          :initarg :w :type integer)
   (height :accessor h :initform 12
           :initarg :h :type integer)
   (states :accessor states :initform '()
           :initarg :states)))

;;; Constructors

(defun make-puyo (color)
  (make-instance 'puyo :color color))

;; maybe add switch to fill up along i or out along j
(defun make-simple-puyos (puyo-list)
  "Makes an array large enough to contain the listed puyos and fills it."
  (let* ((near (nearest-square (length puyo-list)))
         (puyos (make-array `(,near ,near))))
    (loop for i from 0 below near do
         (loop for j from 0 below near do
              (setf (aref puyos i j) (nth (+ (* i near) j) puyo-list))))
    puyos))

(defun nearest-square (limit)
  "Returns the side length of a square large enough to encompass limit."
  (let ((i 1))
    (loop while (< (* i i) limit) do
         (incf i))
    i))

(defun make-double-puyos (puyo)
  (make-array 2 :initial-element puyo))

(defun make-puyopuyo (puyos)
  (make-instance 'puyopuyo :puyos puyos))

(defun make-state (h w)
  (make-instance 'state :puyos (make-array (list h w) :initial-element nil)))

(defun make-board ()
  (make-instance 'board))

(defun make-board-with-state (states)
  (make-instance 'board :states states))

;;; Puyo Ops

(defun is-trash (puyo)
  (eq (color puyo) 'trash))

(defun get-colors (puyos)
  (let ((colors '()))
    (destructuring-bind (h w) (array-dimensions puyos)
      (loop for y from 0 below h do
           (loop for x from 0 below w do
                (push (color (aref puyos x y)) colors))))
    colors))

;; check if there's outstanding combos in a puyos array using
;; hashing and a flood-fill variant
(defun has-combo (puyos)
  (let ((open-set (make-hash-table :test #'equal :size 96))
        (closed-set (make-hash-table :test #'equal :size 96)))
    (hash-puyos puyos open-set)
    (loop for color in (remove 'trash *colors*) do
         ())))

;; put whole puyo or just color?
(defun hash-puyos (puyos hash-table)
  (destructuring-bind (h w) (array-dimensions puyos)
    (loop for y from 0 below h do
         (loop for x from 0 below w do
              (setf (gethash (list x y) hash-table) (aref puyos y x)))))
  (maphash #'(lambda (key value)
               (when (null value)
                 (remhash key hash-table)))
           hash-table))

(defun in-bounds (refs array)
  (destructuring-bind (h w) (array-dimensions array)
    (destructuring-bind (y x) refs
      (and (<= 0 y)
           (>= (1- h) y)
           (<= 0 x)
           (>= (1- w) x)))))

;; shifts puyos in their array once to simulate rotation
(defun rotate (puyos &optional (clockwise nil)) nil)

;;; State Ops

(defgeneric get-dimensions (object)) ;; board or state dimensions

(defmethod get-dimensions ((s state))
  (array-dimensions (puyos s)))

(defun get-puyo (state x y)
  (aref (puyos state) x y))

(defun set-puyo (state puyo x y)
  (setf (aref (puyos state) x y) puyo))

(defun set-puyos (state puyos x y) nil)

(defun resolvedp ()
  "Check if state is resolved: no outstanding chains.")

;;; Board Ops

(defmethod get-dimensions ((b board))
  (list (h b) (w b)))

(defun state-count (board)
  (length (states board))) ;; amount of states in a board

(defun push-state (state board)
  (when (not (equal (get-dimensions state)
                    (get-dimensions board)))
    (error "Board and state dimension mismatch."))
  (push state (states board)))

(defun print-state (b index)
  (let  ((state (nth index (states b))))
    (destructuring-bind (h w) (array-dimensions (puyos state))
      (loop for y from (1- h) downto 0 do
           (loop for x from 0 below w do
                (let ((p (aref (puyos state) y x)))
                  (cond ((null p) (format t " . "))
                        ((eq (color p) 'purple) (format t " p "))
                        ((eq (color p) 'red) (format t " r "))
                        ((eq (color p) 'green) (format t " g "))
                        ((eq (color p) 'blue) (format t " b "))
                        ((eq (color p) 'yellow) (format t " y "))
                        ((eq (color p) 'trash) (format t " x ")))))
           (format t "~%")))))

(defun settledp (state)
  "Check that no pieces have empty space below them."
  (destructuring-bind (h w) (array-dimensions (puyos state))
    (loop for y from 1 below h do
      (loop for x from 0 below w do
           (when (and (not (null (aref (puyos state) y x)))
                      (null (aref (puyos state) (1- y) x)))
             (return-from settledp nil)))))
  t)

(defun project-states () nil) ;; give next puyo drop and project resultant states

;;; Testing

(defvar tmpboard (make-board))
(defvar state (make-array '(12 6) :element-type 'puyo :initial-element nil))
(defvar 2gpuyo (make-simple-puyos (list (make-puyo 'green) (make-puyo 'green))))
